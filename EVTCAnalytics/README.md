# GW2Scratch.EVTCAnalytics

A .NET library for parsing and analyzing EVTC logs generated by arcdps, an addon for Guild Wars 2.
Built with integration in other projects in mind. Currently has a very unstable API, changes are to be expected.

The library currently targets `netstandard2.1`.

## Features

- Get raw agent, skill and combat item data from logs
- Get agents and processed events with structured data
- Get encounter results

## Example usage

See the [sample project](../EVTCAnalytics.Sample) for a full example.
```cs
string filename = "example.zevtc";

var parser = new EVTCParser();      // Used to read a log file and get raw data out of it
var processor = new LogProcessor(); // Used to process the raw data

// The parsed log contains raw data from the EVTC file
ParsedLog parsedLog = parser.ParseLog(filename);

// The log after processing the raw data into structured events and agents.
Log log = processor.ProcessLog(parsedLog);

// At this point, we can do anything with the processed data, and use the LogAnalyzer
// for easy access to most common results with caching.
var analyzer = new LogAnalyzer(log);

Encounter encounter = analyzer.GetEncounter();

// Encounter names are available for some languages, we use the target name if it's not.
if (EncounterNames.TryGetEncounterNameForLanguage(GameLanguage.English, encounter, out string name))
    Console.WriteLine($"Encounter: {name}");
else
    Console.WriteLine($"Encounter: {log.MainTarget?.Name ?? "unknown target"}");

Console.WriteLine($"Result: {analyzer.GetResult()}");
Console.WriteLine($"Mode: {analyzer.GetMode()}");
Console.WriteLine($"Duration: {analyzer.GetEncounterDuration()}");

// The processed log allows easy access to data about agents
foreach (var player in log.Agents.OfType<Player>())
{
    Console.WriteLine($"{player.Name} - {player.AccountName} - {player.Profession} - {player.EliteSpecialization}");
}

// Events may be accessed as well
foreach (var deadEvent in log.Events.OfType<AgentDeadEvent>())
{
    if (deadEvent.Agent is Player player)
        Console.WriteLine($"{player.Name} died at {deadEvent.Time}.");
}
```

## Contributing

### Adding a new encounter

Introducing support for a new encounter requires multiple steps:

- Add a new value to the Encounter enum in `GameData/Encounters/Encounter.cs`
- Specify a Category for this Encounter in `GameData/Encounters/EncounterCategories.cs`
- Specify an English name for this Encounter in `GameData/Encounters/EncounterNames.cs`

The presence of category and name is checked running tests defined
in `EVTCAnalytics.Tests`, run these to verify this has been done this correctly.

After doing this, add a way to identify the newly added encounter
in the `IdentifyEncounter()` method of the `Processing/DefaultEncounterIdentifier.cs`.
This will be done by checking the species id of the main target in almost most cases.
The most common exception is fights that may register a different boss in the
same instance if the recording player is too close to them.

In case you do not have the species id of the NPC, you can use arcdps to show a window with details
that includes it if you select the NPC. The default shortcut for this window is Alt+Shift+S.

The last step missing is to provide custom `EncounterData` if needed.
`EncounterData` contains definitions that are used to determine whether
the encounter was successful, whether it was in Challenge Mode and others.
You might need to implement new Determiners in case the encounter is not very
typical. If you do, try to make them generic enough to be reusable in case
similar encounters are introduced in the future.

The EVTC Inspector is very useful for finding reliable ways to check results
and to figure out what is happening in the logs.

After specifying all this, gather enough logs to verify your `EncounterData`
works as expected and you are done.